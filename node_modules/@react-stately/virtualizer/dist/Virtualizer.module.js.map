{"mappings":"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","sources":["packages/@react-stately/virtualizer/src/Virtualizer.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CancelablePromise, easeOut, tween} from './tween';\nimport {Collection, Key} from '@react-types/shared';\nimport {concatIterators, difference, isSetEqual} from './utils';\nimport {\n  InvalidationContext,\n  ScrollAnchor,\n  ScrollToItemOptions,\n  VirtualizerDelegate,\n  VirtualizerOptions\n} from './types';\nimport {Layout} from './Layout';\nimport {LayoutInfo} from './LayoutInfo';\nimport {OverscanManager} from './OverscanManager';\nimport {Point} from './Point';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {Transaction} from './Transaction';\n\n/**\n * The CollectionView class renders a scrollable collection of data using customizable layouts,\n * and manages animated updates to the data over time. It supports very large collections by\n * only rendering visible views to the DOM, reusing them as you scroll. Collection views can\n * present any type of view, including non-item views such as section headers and footers.\n * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction\n * with the collection, including drag and drop, multiple selection, and keyboard interacton.\n *\n * Collection views get their data from a {@link DataSource} object that you provide. Items are\n * grouped into sections by the data source, and the collection view calls its methods to retrieve\n * the data. When data changes, the data source emits change events, and the collection view\n * updates as appropriate, optionally with an animated transition. There is one built-in data source\n * implementation, {@link ArrayDataSource}, which renders content from a 2d array.\n *\n * Collection views use {@link Layout} objects to compute what views should be visible, and how\n * to position and style them. This means that collection views can have their items arranged in\n * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed\n * dynamically at runtime as well, optionally with an animated transition between the layouts.\n *\n * Layouts produce information on what views should appear in the collection view, but do not create\n * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object\n * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.\n * The delegate determines what type of view to display for each item, and creates instances of\n * views as needed by the collection view. Those views are then reused by the collection view as\n * the user scrolls through the content.\n */\nexport class Virtualizer<T extends object, V, W> {\n  /**\n   * The collection view delegate. The delegate is used by the collection view\n   * to create and configure views.\n   */\n  delegate: VirtualizerDelegate<T, V, W>;\n\n  /** The duration of animated layout changes, in milliseconds. Default is 500ms. */\n  transitionDuration: number;\n\n  /**\n   * Whether to enable scroll anchoring. This will attempt to restore the scroll position\n   * after layout changes outside the viewport. Default is off.\n   */\n  anchorScrollPosition: boolean;\n\n  /** Whether to anchor the scroll position when at the top of the content. Default is off. */\n  anchorScrollPositionAtTop: boolean;\n\n  /**\n   * Whether to overscan the visible area to pre-render items slightly outside and\n   * improve performance. Default is on.\n   */\n  shouldOverscan: boolean;\n\n  private _collection: Collection<T>;\n  private _layout: Layout<T>;\n  private _contentSize: Size;\n  private _visibleRect: Rect;\n  private _visibleLayoutInfos: Map<Key, LayoutInfo>;\n  private _reusableViews: {[type: string]: ReusableView<T, V>[]};\n  private _visibleViews: Map<Key, ReusableView<T, V>>;\n  private _renderedContent: WeakMap<T, V>;\n  private _children: Set<ReusableView<T, V>>;\n  private _invalidationContext: InvalidationContext<T, V> | null;\n  private _overscanManager: OverscanManager;\n  private _persistedKeys: Set<Key>;\n  private _relayoutRaf: number | null;\n  private _scrollAnimation: CancelablePromise<void> | null;\n  private _isScrolling: boolean;\n  private _sizeUpdateQueue: Map<Key, Size>;\n  private _animatedContentOffset: Point;\n  private _transaction: Transaction<T, V> | null;\n  private _nextTransaction: Transaction<T, V> | null;\n  private _transactionQueue: Transaction<T, V>[];\n\n  constructor(options: VirtualizerOptions<T, V, W> = {}) {\n    this._contentSize = new Size;\n    this._visibleRect = new Rect;\n\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new OverscanManager();\n    this._persistedKeys = new Set();\n\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new Point(0, 0);\n\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    // Set options from passed object if given\n    this.transitionDuration = options.transitionDuration ?? 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n    for (let key of ['delegate', 'size', 'layout', 'collection']) {\n      if (options[key]) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  _setContentSize(size: Size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n\n  _setContentOffset(offset: Point) {\n    let rect = new Rect(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n\n  /**\n   * Get the size of the scrollable content.\n   */\n  get contentSize(): Size {\n    return this._contentSize;\n  }\n\n  /**\n   * Get the collection view's currently visible rectangle.\n   */\n  get visibleRect(): Rect {\n    return this._visibleRect;\n  }\n\n  /**\n   * Set the collection view's currently visible rectangle.\n   */\n  set visibleRect(rect: Rect) {\n    this._setVisibleRect(rect);\n  }\n\n  _setVisibleRect(rect: Rect, forceUpdate = false) {\n    let current = this._visibleRect;\n\n    // Ignore if the rects are equal\n    if (rect.equals(current)) {\n      return;\n    }\n\n    if (this.shouldOverscan) {\n      this._overscanManager.setVisibleRect(rect);\n    }\n\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n    this._resetAnimatedContentOffset();\n    this._visibleRect = rect;\n\n    if (shouldInvalidate) {\n      // We are already in a layout effect when this method is called, so relayoutNow is appropriate.\n      this.relayoutNow({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });\n    } else {\n      this.updateSubviews(forceUpdate);\n    }\n  }\n\n  get collection(): Collection<T> {\n    return this._collection;\n  }\n\n  set collection(data: Collection<T>) {\n    this._setData(data);\n  }\n\n  private _setData(data: Collection<T>) {\n    if (data === this._collection) {\n      return;\n    }\n\n    if (this._collection) {\n      this._runTransaction(() => {\n        this._collection = data;\n      }, this.transitionDuration > 0);\n    } else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n\n  /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n\n  /**\n   * Returns the item with the given key.\n   */\n  getItem(key: Key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  get persistedKeys(): Set<Key> {\n    return this._persistedKeys;\n  }\n\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  set persistedKeys(persistedKeys: Set<Key>) {\n    if (!isSetEqual(persistedKeys, this._persistedKeys)) {\n      this._persistedKeys = persistedKeys;\n      this.updateSubviews();\n    }\n  }\n\n  /** Returns whether the given key, or an ancestor, is persisted. */\n  isPersistedKey(key: Key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this._persistedKeys.has(key)) {\n      return true;\n    }\n\n    // If not, check if the key is an ancestor of any of the persisted keys.\n    for (let k of this._persistedKeys) {\n      while (k != null) {\n        let layoutInfo = this.layout.getLayoutInfo(k);\n        if (!layoutInfo) {\n          break;\n        }\n\n        k = layoutInfo.parentKey;\n\n        if (k === key) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get the collection view's layout.\n   */\n  get layout(): Layout<T> {\n    return this._layout;\n  }\n\n  /**\n   * Set the collection view's layout.\n   */\n  set layout(layout: Layout<T>) {\n    this.setLayout(layout);\n  }\n\n  /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */\n  setLayout(layout: Layout<T>, animated = false) {\n    if (layout === this._layout) {\n      return;\n    }\n\n    let applyLayout = () => {\n      if (this._layout) {\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      }\n\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n\n    if (animated) {\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);\n    } else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n\n  private _getReuseType(layoutInfo: LayoutInfo, content: T | null) {\n    if (layoutInfo.type === 'item' && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n      return {type, reuseType};\n    }\n\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n\n  getReusableView(layoutInfo: LayoutInfo): ReusableView<T, V> {\n    let content = this.getItem(layoutInfo.key);\n    let {reuseType} = this._getReuseType(layoutInfo, content);\n\n    if (!this._reusableViews[reuseType]) {\n      this._reusableViews[reuseType] = [];\n    }\n\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0\n      ? reusable.pop()\n      : new ReusableView<T, V>(this);\n\n    view.viewType = reuseType;\n\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n\n    view.layoutInfo = layoutInfo;\n\n    this._renderView(view);\n    return view;\n  }\n\n  private _renderView(reusableView: ReusableView<T, V>) {\n    let {type, key} = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  private _renderContent(type: string, content: T) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) {\n      return cached;\n    }\n\n    let rendered = this.delegate.renderView(type, content);\n    if (content) {\n      this._renderedContent.set(content, rendered);\n    }\n    return rendered;\n  }\n\n  /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */\n  get visibleViews(): ReusableView<T, V>[] {\n    return Array.from(this._visibleViews.values());\n  }\n\n  /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */\n  getView(key: Key): ReusableView<T, V> | null {\n    return this._visibleViews.get(key) || null;\n  }\n\n  /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */\n  getViewsOfType(type: string): ReusableView<T, V>[] {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n\n  /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */\n  keyForView(view: ReusableView<T, V>): Key | null {\n    if (view && view.layoutInfo) {\n      return view.layoutInfo.key;\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns the key for the item view currently at the given point.\n   */\n  keyAtPoint(point: Point): Key | null {\n    let rect = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) {\n        return layoutInfo.key;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n\n  /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */\n  relayout(context: InvalidationContext<T, V> = {}) {\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') {\n      return;\n    }\n\n    // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n\n    this._invalidationContext = context;\n  }\n\n  /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */\n  relayoutNow(context: InvalidationContext<T, V> = this._invalidationContext || {}) {\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n      // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n      context = {...this._invalidationContext, ...context};\n    }\n\n    // Reset the invalidation context\n    this._invalidationContext = null;\n\n    // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n    if (!this.layout || !this._collection || this._scrollAnimation) {\n      return;\n    }\n\n    let scrollAnchor = this._getScrollAnchor();\n\n    // Trigger the beforeLayout hook, if provided\n    if (typeof context.beforeLayout === 'function') {\n      context.beforeLayout();\n    }\n\n    // Validate the layout\n    this.layout.validate(context);\n    this._setContentSize(this.layout.getContentSize());\n\n    // Trigger the afterLayout hook, if provided\n    if (typeof context.afterLayout === 'function') {\n      context.afterLayout();\n    }\n\n    // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.getVisibleRect();\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n\n    let hasLayoutUpdates = false;\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else {\n        this._setContentOffset(new Point(contentOffsetX, contentOffsetY));\n      }\n    } else {\n      hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    }\n\n    // Apply layout infos, unless this is coming from an animated transaction\n    if (!(context.transaction && context.animated)) {\n      this._applyLayoutInfos();\n    }\n\n    // Wait for animations, and apply the afterAnimation hook, if provided\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n\n      let done = () => {\n        this._disableTransitions();\n\n        // Reset scroll position after animations (see above comment).\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {x, y} = this.getVisibleRect();\n          this._resetAnimatedContentOffset();\n          this._setContentOffset(new Point(x, y));\n        }\n\n        if (typeof context.afterAnimation === 'function') {\n          context.afterAnimation();\n        }\n      };\n\n      // Sometimes the animation takes slightly longer than expected.\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === 'function') {\n      context.afterAnimation();\n    }\n  }\n\n  /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */\n  private _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) {\n      return;\n    }\n\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n      this._children.delete(view);\n      this._children.add(view);\n    }\n  }\n\n  private _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n\n  private _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n\n  private _getScrollAnchor(): ScrollAnchor | null {\n    if (!this.anchorScrollPosition) {\n      return null;\n    }\n\n    let visibleRect = this.getVisibleRect();\n\n    // Ask the delegate to provide a scroll anchor, if possible\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {key, layoutInfo, corner, offset};\n        }\n      }\n    }\n\n    // No need to anchor the scroll position if it is at the top\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {\n      return null;\n    }\n\n    // Find a view with a visible corner that has the smallest distance to the top of the collection view\n    let cornerAnchor: ScrollAnchor | null = null;\n\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          if (!cornerAnchor || (offset < cornerAnchor.offset)) {\n            cornerAnchor = {key, layoutInfo, corner, offset};\n          }\n        }\n      }\n    }\n\n    return cornerAnchor;\n  }\n\n  private _restoreScrollAnchor(scrollAnchor: ScrollAnchor | null, context: InvalidationContext<T, V>) {\n    let contentOffset = this.getVisibleRect();\n\n    if (scrollAnchor) {\n      let finalAnchor = context.transaction?.animated\n        ? context.transaction.finalMap.get(scrollAnchor.key)\n        : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n      if (finalAnchor) {\n        let adjustment = (finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y) - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n\n    return contentOffset;\n  }\n\n  getVisibleRect(): Rect {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new Rect(x, y, v.width, v.height);\n  }\n\n  getVisibleLayoutInfos() {\n    let isTestEnv = process.env.NODE_ENV === 'test' && !process.env.VIRT_ON;\n\n    let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientWidth');\n    let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes('clientHeight');\n\n    let rect;\n    if (isTestEnv && !(isClientWidthMocked && isClientHeightMocked)) {\n      rect = this._getContentRect();\n    } else {\n      rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    }\n\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n\n  private _getLayoutInfoMap(rect: Rect, copy = false) {\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map;\n\n    for (let layoutInfo of layoutInfos) {\n      if (copy) {\n        layoutInfo = layoutInfo.copy();\n      }\n\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  updateSubviews(forceUpdate = false) {\n    if (!this._collection) {\n      return;\n    }\n\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate;\n\n    // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({toAdd, toRemove, toUpdate} = difference(currentlyVisible, visibleLayoutInfos));\n\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) {\n          continue;\n        }\n\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) {\n          toUpdate.delete(key);\n        } else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {reuseType} = this._getReuseType(view.layoutInfo, item);\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      }\n\n      // We are done if the sets are equal\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) {\n          this._applyLayoutInfos();\n        }\n\n        return;\n      }\n    }\n\n    // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n    let removed = new Set<ReusableView<T, V>>();\n\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n      if (view) {\n        removed.add(view);\n        this._visibleViews.delete(key);\n\n        // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n        if (this._transaction) {\n          this._transaction.toRemove.set(key, view);\n        } else {\n          this.reuseView(view);\n        }\n      }\n    }\n\n    for (let key of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      let view: ReusableView<T, V> | void;\n\n      // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key)) {\n          layoutInfo = this._transaction.initialLayoutInfo.get(key);\n        }\n\n        view = this._transaction.toRemove.get(key);\n        if (view) {\n          this._transaction.toRemove.delete(key);\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo);\n\n        // Add the view to the DOM if needed\n        if (!removed.has(view)) {\n          this._children.add(view);\n        }\n      }\n\n      this._visibleViews.set(key, view);\n      removed.delete(view);\n    }\n\n    for (let key of toUpdate) {\n      let view = currentlyVisible.get(key) as ReusableView<T, V>;\n      this._renderedContent.delete(key);\n      this._renderView(view);\n    }\n\n    // Remove the remaining rows to delete from the DOM\n    if (!this._transaction) {\n      this.removeViews(removed);\n    }\n\n    this._correctItemOrder();\n    this._flushVisibleViews();\n\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n    if (hasLayoutUpdates) {\n      requestAnimationFrame(() => {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (this._transaction) {\n          requestAnimationFrame(() => this._applyLayoutInfos());\n        }\n      });\n    }\n\n    return hasLayoutUpdates;\n  }\n\n  afterRender() {\n    if (this._transactionQueue.length > 0) {\n      this._processTransactionQueue();\n    } else if (this._invalidationContext) {\n      this.relayoutNow();\n    }\n\n    if (this.shouldOverscan) {\n      this._overscanManager.collectMetrics();\n    }\n  }\n\n  private _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent hierarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this hierarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n    for (let view of this._children) {\n      if (view.layoutInfo?.parentKey != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) {\n        viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      }\n\n      viewsByParentKey.get(view.layoutInfo?.parentKey)?.push(view);\n      if (!viewsByParentKey.has(view.layoutInfo?.key)) {\n        viewsByParentKey.set(view.layoutInfo?.key, []);\n      }\n    }\n\n    let buildTree = (parent: ReusableView<T, V>, views: ReusableView<T, V>[]): W[] => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(\n        parent,\n        view,\n        children,\n        (childViews) => buildTree(view, childViews)\n      );\n    });\n\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n\n  private _applyLayoutInfo(view: ReusableView<T, V>, layoutInfo: LayoutInfo) {\n    if (view.layoutInfo === layoutInfo) {\n      return false;\n    }\n\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n\n  private _applyLayoutInfos() {\n    let updated = false;\n\n    // Apply layout infos to visible views\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (cur?.key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    // Apply final layout infos for views that will be removed\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        if (cur?.key != null) {\n          let layoutInfo = this.layout.getLayoutInfo(cur.key);\n          if (this._applyLayoutInfo(view, layoutInfo)) {\n            updated = true;\n          }\n        }\n      }\n\n      for (let view of this._transaction.removed.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      this._flushVisibleViews();\n    }\n  }\n\n  private _hasLayoutUpdates() {\n    if (!this._transaction) {\n      return false;\n    }\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) {\n        return true;\n      }\n\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if (\n        // Uses equals rather than pointEquals so that width/height changes are taken into account\n        !cur.rect.equals(layoutInfo.rect) ||\n        cur.opacity !== layoutInfo.opacity ||\n        cur.transform !== layoutInfo.transform\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reuseView(view: ReusableView<T, V>) {\n    view.prepareForReuse();\n    this._reusableViews[view.viewType].push(view);\n  }\n\n  removeViews(toRemove: Set<ReusableView<T, V>>) {\n    for (let view of toRemove) {\n      this._children.delete(view);\n    }\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) {\n      return;\n    }\n\n    // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n      return;\n    }\n\n    // @ts-ignore\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) {\n      this.relayout();\n    }\n  }\n\n  startScrolling() {\n    this._isScrolling = true;\n  }\n\n  endScrolling() {\n    this._isScrolling = false;\n    this._correctItemOrder();\n    this._flushVisibleViews();\n  }\n\n  private _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new Point(0, 0);\n      this._applyLayoutInfos();\n    }\n  }\n\n  /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */\n  scrollToItem(key: Key, options?: ScrollToItemOptions) {\n    // key can be 0, so check if null or undefined\n    if (key == null) {\n      return;\n    }\n\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return;\n    }\n\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) {\n        x = minX;\n      } else if (layoutInfo.rect.maxX > maxX) {\n        x += layoutInfo.rect.maxX - maxX;\n      }\n    }\n\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) {\n        y = minY;\n      } else if (layoutInfo.rect.maxY > maxY) {\n        y += layoutInfo.rect.maxY - maxY;\n      }\n    }\n\n    return this.scrollTo(new Point(x, y), duration);\n  }\n\n  /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */\n  scrollTo(offset: Point, duration: number = 300): Promise<void> {\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n      this._scrollAnimation = null;\n    }\n\n    // Set the content offset synchronously if the duration is zero\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n      return Promise.resolve();\n    }\n\n    this.startScrolling();\n\n    this._scrollAnimation = tween(this.visibleRect, offset, duration, easeOut, offset => {this._setContentOffset(offset);});\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null;\n\n      // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n      for (let [key, size] of this._sizeUpdateQueue) {\n        this.updateItemSize(key, size);\n      }\n\n      this._sizeUpdateQueue.clear();\n      this.relayout();\n      this._processTransactionQueue();\n      this.endScrolling();\n    });\n\n    return this._scrollAnimation;\n  }\n\n  private _runTransaction(action: () => void, animated?: boolean) {\n    this._startTransaction();\n    if (this._nextTransaction) {\n      this._nextTransaction.actions.push(action);\n    }\n    this._endTransaction(animated);\n  }\n\n  private _startTransaction() {\n    if (!this._nextTransaction) {\n      this._nextTransaction = new Transaction;\n    }\n\n    this._nextTransaction.level++;\n  }\n\n  private _endTransaction(animated?: boolean) {\n    if (!this._nextTransaction) {\n      return false;\n    }\n\n    // Save whether the transaction should be animated.\n    if (animated != null) {\n      this._nextTransaction.animated = animated;\n    }\n\n    // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n    if (--this._nextTransaction.level > 0) {\n      return false;\n    }\n\n    // Do nothing for empty transactions\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    }\n\n    // Default animations to true\n    if (this._nextTransaction.animated == null) {\n      this._nextTransaction.animated = true;\n    }\n\n    // Enqueue the transaction\n    this._transactionQueue.push(this._nextTransaction);\n    this._nextTransaction = null;\n\n    return true;\n  }\n\n  private _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) {\n      return;\n    }\n\n    let next = this._transactionQueue.shift();\n    if (next) {\n      this._performTransaction(next);\n    }\n  }\n\n  private _getContentRect(): Rect {\n    return new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n\n  private _performTransaction(transaction: Transaction<T, V>) {\n    this._transaction = transaction;\n\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) {\n          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        }\n\n        // Apply the actions that occurred during this transaction\n        for (let action of transaction.actions) {\n          action();\n        }\n      },\n\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n          this._setupTransactionAnimations(transaction);\n        } else {\n          this._transaction = null;\n        }\n      },\n\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n          for (let view of concatIterators(transaction.toRemove.values(), transaction.removed.values())) {\n            this._children.delete(view);\n            this.reuseView(view);\n          }\n        }\n\n        this._transaction = null;\n\n        // Ensure DOM order is correct for accessibility after animations are complete\n        this._correctItemOrder();\n        this._flushVisibleViews();\n\n        this._processTransactionQueue();\n      }\n    });\n  }\n\n  private _setupTransactionAnimations(transaction: Transaction<T, V>) {\n    let {initialMap, finalMap} = transaction;\n\n    // Store initial and final layout infos for animations\n    for (let [key, layoutInfo] of initialMap) {\n      if (finalMap.has(key)) {\n        // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n      } else {\n        // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n      }\n    }\n\n    // Get initial layout infos for views that were added\n    for (let [key, layoutInfo] of finalMap) {\n      if (!initialMap.has(key)) {\n        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n        transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n      }\n    }\n\n    // Figure out which views were removed.\n    for (let [key, view] of this._visibleViews) {\n      // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n      // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n      // added, removed... etc in a loop.\n      if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n        transaction.removed.set(key, view);\n        this._visibleViews.delete(key);\n\n        // In case something weird happened, where we have a view but no\n        // initial layout info, use the one attached to the view.\n        if (view.layoutInfo) {\n          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) {\n            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n          }\n        }\n      }\n    }\n  }\n}\n"],"names":[],"version":3,"file":"Virtualizer.module.js.map"}